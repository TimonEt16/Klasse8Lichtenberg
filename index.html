<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Astora - Schlange der Ewigkeit</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=MedievalSharp&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            background: linear-gradient(135deg, #0a0e18, #121a2b, #0a0f15);
            color: #e0d6c3;
            font-family: 'MedievalSharp', 'Orbitron', monospace;
            user-select: none;
            cursor: none;
            position: relative;
        }

        #gameCanvas {
            display: block;
            background: radial-gradient(ellipse at center, #0a111a, #070d12, #04090c);
            position: relative;
            z-index: 1;
        }

        .boost-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 2;
            display: none;
        }

        .boost-overlay.active {
            display: block;
            animation: boostGlow 0.8s infinite alternate;
        }

        @keyframes boostGlow {
            0% {
                box-shadow: inset 0 0 20px 5px rgba(255, 107, 53, 0.3);
            }
            100% {
                box-shadow: inset 0 0 40px 15px rgba(255, 107, 53, 0.7);
            }
        }

        .ui {
            position: absolute;
            top: 25px;
            left: 25px;
            z-index: 100;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .game-stats {
            background: rgba(10, 15, 25, 0.85);
            padding: 20px;
            border-radius: 12px;
            backdrop-filter: blur(15px);
            border: 1px solid rgba(123, 90, 50, 0.5);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
            position: relative;
            overflow: hidden;
            border-image: linear-gradient(to bottom right, #7b5a32, #d4af37) 1;
        }

        .game-stats::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(123, 90, 50, 0.1), transparent);
            animation: shimmer 3s infinite;
        }

        @keyframes shimmer {
            0% { left: -100%; }
            100% { left: 100%; }
        }

        .stat-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 8px 0;
            font-size: 16px;
            font-weight: 700;
            text-shadow: 0 0 3px rgba(0, 0, 0, 0.8);
        }

        .stat-label {
            color: #d4af37;
        }

        .stat-value {
            color: #ffffff;
        }

        #boostBtn {
            padding: 16px 32px;
            font-size: 18px;
            font-weight: 900;
            background: linear-gradient(135deg, #d4af37, #ffd700, #ffa500);
            border: none;
            border-radius: 8px;
            cursor: pointer;
            color: #2a0a00;
            box-shadow: 0 6px 20px rgba(212, 175, 55, 0.4);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            text-transform: uppercase;
            letter-spacing: 1px;
            position: relative;
            overflow: hidden;
            font-family: 'MedievalSharp', cursive;
            border: 2px solid #7b5a32;
        }

        #boostBtn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: left 0.5s;
        }

        #boostBtn:hover {
            transform: translateY(-3px) scale(1.02);
            box-shadow: 0 10px 30px rgba(212, 175, 55, 0.6);
        }

        #boostBtn:hover::before {
            left: 100%;
        }

        #boostBtn:active {
            transform: translateY(-1px);
        }

        #boostBtn.boosting {
            background: linear-gradient(135deg, #ff6b35, #ff8e53, #ffa726);
            animation: boostPulse 0.6s infinite alternate;
            box-shadow: 0 0 30px rgba(255, 107, 53, 0.8);
        }

        @keyframes boostPulse {
            0% { transform: scale(1) rotate(0deg); }
            100% { transform: scale(1.05) rotate(1deg); }
        }

        .game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0);
            background: rgba(10, 15, 25, 0.95);
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            border: 2px solid #d4af37;
            display: none;
            backdrop-filter: blur(20px);
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.8);
            transition: transform 0.5s cubic-bezier(0.68, -0.55, 0.265, 1.55);
            z-index: 200;
            border-image: linear-gradient(to bottom right, #d4af37, #ffd700) 1;
            width: 80%;
            max-width: 500px;
        }

        .game-over.show {
            transform: translate(-50%, -50%) scale(1);
        }

        .game-over h2 {
            color: #d4af37;
            margin: 0 0 20px 0;
            font-size: 42px;
            font-weight: 900;
            text-shadow: 0 0 10px rgba(212, 175, 55, 0.5);
            animation: glow 2s ease-in-out infinite alternate;
            font-family: 'MedievalSharp', cursive;
        }

        @keyframes glow {
            from { text-shadow: 0 0 10px rgba(212, 175, 55, 0.5); }
            to { text-shadow: 0 0 20px rgba(212, 175, 55, 0.8), 0 0 30px rgba(212, 175, 55, 0.3); }
        }

        .final-stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin: 20px 0;
        }

        .final-stat {
            background: rgba(255, 255, 255, 0.05);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid rgba(212, 175, 55, 0.2);
        }

        .final-stat strong {
            color: #d4af37;
        }

        .restart-btn {
            padding: 15px 30px;
            background: linear-gradient(135deg, #7b5a32, #d4af37);
            border: none;
            border-radius: 10px;
            color: #fff;
            cursor: pointer;
            font-size: 18px;
            font-weight: 700;
            margin-top: 20px;
            transition: all 0.3s;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-family: 'MedievalSharp', cursive;
            border: 1px solid #ffd700;
        }

        .restart-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(212, 175, 55, 0.4);
        }

        .leaderboard {
            position: absolute;
            top: 25px;
            right: 25px;
            background: rgba(10, 15, 25, 0.85);
            padding: 20px;
            border-radius: 12px;
            backdrop-filter: blur(15px);
            border: 1px solid rgba(123, 90, 50, 0.5);
            max-width: 300px;
            border-image: linear-gradient(to bottom right, #7b5a32, #d4af37) 1;
        }

        .leaderboard h3 {
            color: #d4af37;
            margin-bottom: 15px;
            text-align: center;
            font-weight: 900;
            font-family: 'MedievalSharp', cursive;
            font-size: 24px;
        }

        .score-entry {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid rgba(212, 175, 55, 0.2);
        }

        .custom-cursor {
            position: fixed;
            width: 24px;
            height: 24px;
            background: radial-gradient(circle, #d4af37, transparent 70%);
            border-radius: 50%;
            pointer-events: none;
            z-index: 1000;
            mix-blend-mode: difference;
            transition: transform 0.1s;
        }

        .particle {
            position: absolute;
            pointer-events: none;
            border-radius: 50%;
            animation: particleFloat 2s linear forwards;
        }

        @keyframes particleFloat {
            0% {
                opacity: 1;
                transform: scale(1) translateY(0);
            }
            100% {
                opacity: 0;
                transform: scale(0) translateY(-100px);
            }
        }

        .minimap {
            position: absolute;
            bottom: 25px;
            right: 25px;
            width: 200px;
            height: 150px;
            background: rgba(10, 15, 25, 0.8);
            border: 2px solid rgba(123, 90, 50, 0.5);
            border-radius: 8px;
            backdrop-filter: blur(10px);
            z-index: 100;
        }

        .ability-container {
            position: absolute;
            bottom: 25px;
            left: 25px;
            display: flex;
            gap: 15px;
            z-index: 100;
        }

        .ability-btn {
            width: 70px;
            height: 70px;
            border-radius: 50%;
            background: rgba(10, 15, 25, 0.7);
            border: 2px solid rgba(212, 175, 55, 0.5);
            color: #d4af37;
            font-size: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s;
            position: relative;
            overflow: hidden;
            box-shadow: 0 0 10px rgba(212, 175, 55, 0.3);
        }

        .ability-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 0 20px rgba(212, 175, 55, 0.5);
        }

        .cooldown-overlay {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 0%;
            background: rgba(255, 0, 0, 0.3);
            pointer-events: none;
            transition: height 0.3s;
        }

        .level-indicator {
            position: absolute;
            top: 25px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(10, 15, 25, 0.7);
            padding: 10px 25px;
            border-radius: 20px;
            border: 1px solid rgba(212, 175, 55, 0.5);
            font-weight: bold;
            z-index: 100;
            font-family: 'MedievalSharp', cursive;
            color: #d4af37;
            border-image: linear-gradient(to right, #7b5a32, #d4af37) 1;
        }

        .xp-bar {
            height: 6px;
            background: rgba(123, 90, 50, 0.3);
            border-radius: 3px;
            margin-top: 8px;
            overflow: hidden;
        }

        .xp-progress {
            height: 100%;
            background: linear-gradient(90deg, #7b5a32, #d4af37);
            width: 0%;
            transition: width 0.3s;
        }
        
        .controls-hint {
            position: absolute;
            bottom: 100px;
            left: 25px;
            background: rgba(10, 15, 25, 0.7);
            padding: 10px 15px;
            border-radius: 10px;
            border: 1px solid rgba(212, 175, 55, 0.5);
            font-size: 14px;
            z-index: 100;
            color: #d4af37;
            font-family: 'MedievalSharp', cursive;
        }
        
        .key-hint {
            display: inline-block;
            background: rgba(123, 90, 50, 0.3);
            padding: 2px 8px;
            border-radius: 4px;
            margin: 0 5px;
            border: 1px solid rgba(212, 175, 55, 0.5);
        }
        
        .game-title {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            color: #d4af37;
            font-size: 36px;
            font-weight: bold;
            text-shadow: 0 0 10px rgba(0, 0, 0, 0.8);
            z-index: 100;
            font-family: 'MedievalSharp', cursive;
            letter-spacing: 2px;
            text-align: center;
        }
        
        .game-title span {
            font-size: 16px;
            display: block;
            letter-spacing: 4px;
            margin-top: -5px;
            color: #ffd700;
        }
        
        .world-boundary {
            position: absolute;
            background: rgba(255, 50, 50, 0.3);
            z-index: 50;
            box-shadow: 0 0 20px rgba(255, 50, 50, 0.5);
        }
        
        /* Ladeanimation verbessert */
        .loader-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #0a0e18;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10000;
            transition: opacity 0.5s, visibility 0.5s;
        }
        
        .loader {
            width: 80px;
            height: 80px;
            border: 10px solid rgba(212, 175, 55, 0.2);
            border-top: 10px solid #d4af37;
            border-radius: 50%;
            animation: spin 1.5s linear infinite;
            margin-bottom: 20px;
        }
        
        .loader-text {
            color: #d4af37;
            font-size: 24px;
            font-family: 'MedievalSharp', cursive;
            text-align: center;
            margin-bottom: 15px;
            animation: pulse 1.5s infinite alternate;
        }
        
        @keyframes pulse {
            0% { transform: scale(1); opacity: 0.8; }
            100% { transform: scale(1.05); opacity: 1; }
        }
        
        .progress-bar {
            width: 300px;
            height: 20px;
            background: rgba(123, 90, 50, 0.3);
            border-radius: 10px;
            overflow: hidden;
            margin-top: 10px;
            box-shadow: inset 0 0 5px rgba(0,0,0,0.3);
        }
        
        .progress {
            height: 100%;
            background: linear-gradient(90deg, #7b5a32, #d4af37);
            width: 0%;
            transition: width 0.3s;
            box-shadow: 0 0 10px rgba(212, 175, 55, 0.5);
        }
        
        .branding {
            position: absolute;
            bottom: 30px;
            color: #d4af37;
            font-family: 'MedievalSharp', cursive;
            text-align: center;
            opacity: 0.8;
        }
        
        .branding h2 {
            font-size: 28px;
            margin-bottom: 5px;
            text-shadow: 0 0 10px rgba(0,0,0,0.8);
        }
        
        .branding p {
            font-size: 14px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        /* Achievement-System */
        .achievement-container {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1000;
        }
        
        .achievement {
            background: rgba(10, 15, 25, 0.9);
            border-left: 5px solid #d4af37;
            padding: 15px;
            margin-bottom: 10px;
            border-radius: 5px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.5);
            transform: translateX(120%);
            transition: transform 0.5s ease;
            min-width: 300px;
            display: flex;
            align-items: center;
        }
        
        .achievement.show {
            transform: translateX(0);
        }
        
        .achievement-icon {
            font-size: 30px;
            margin-right: 15px;
            color: #d4af37;
        }
        
        .achievement-text h3 {
            color: #d4af37;
            margin-bottom: 5px;
        }
        
        /* Audio Controls */
        .audio-controls {
            position: absolute;
            bottom: 25px;
            right: 250px;
            display: flex;
            gap: 10px;
            z-index: 100;
        }
        
        .audio-btn {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: rgba(10, 15, 25, 0.7);
            border: 2px solid rgba(212, 175, 55, 0.5);
            color: #d4af37;
            font-size: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
        }
        
        /* Sprachauswahl */
        .language-selector {
            position: absolute;
            top: 25px;
            right: 350px;
            z-index: 100;
            background: rgba(10, 15, 25, 0.7);
            padding: 10px;
            border-radius: 8px;
            border: 1px solid rgba(212, 175, 55, 0.5);
        }
        
        .language-btn {
            background: none;
            border: none;
            color: #d4af37;
            font-family: 'MedievalSharp', cursive;
            cursor: pointer;
            padding: 5px 10px;
            border-radius: 4px;
        }
        
        .language-btn.active {
            background: rgba(212, 175, 55, 0.3);
        }
        
        /* Level-Up Animation */
        .level-up-animation {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 72px;
            color: #d4af37;
            text-shadow: 0 0 20px rgba(212, 175, 55, 0.8);
            z-index: 1000;
            opacity: 0;
            pointer-events: none;
            animation: levelUpAnim 2s forwards;
            font-family: 'MedievalSharp', cursive;
        }
        
        @keyframes levelUpAnim {
            0% {
                opacity: 0;
                transform: translate(-50%, -50%) scale(0.5);
            }
            50% {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1.2);
            }
            100% {
                opacity: 0;
                transform: translate(-50%, -50%) scale(1.5);
            }
        }
        
        /* Verbesserte Weltgrenzen */
        .world-boundary {
            position: absolute;
            background: rgba(255, 50, 50, 0.3);
            z-index: 50;
            box-shadow: 0 0 20px rgba(255, 50, 50, 0.5);
        }
        
        .boundary-indicator {
            position: absolute;
            background: rgba(255, 50, 50, 0.5);
            z-index: 49;
            box-shadow: 0 0 15px rgba(255, 50, 50, 0.7);
        }
        
        /* Touch-Steuerung f√ºr Mobilger√§te */
        .touch-controls {
            position: fixed;
            bottom: 30px;
            right: 30px;
            width: 120px;
            height: 120px;
            z-index: 100;
            display: none;
        }
        
        .joystick {
            position: absolute;
            width: 80px;
            height: 80px;
            background: rgba(10, 15, 25, 0.7);
            border-radius: 50%;
            border: 2px solid rgba(212, 175, 55, 0.5);
            box-shadow: 0 0 10px rgba(212, 175, 55, 0.3);
        }
        
        .joystick-handle {
            position: absolute;
            width: 40px;
            height: 40px;
            background: rgba(212, 175, 55, 0.8);
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
        
        .touch-boost {
            position: absolute;
            bottom: 30px;
            left: 30px;
            width: 70px;
            height: 70px;
            border-radius: 50%;
            background: rgba(255, 107, 53, 0.7);
            border: 2px solid rgba(255, 200, 50, 0.8);
            color: white;
            font-size: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 100;
            display: none;
            box-shadow: 0 0 15px rgba(255, 107, 53, 0.5);
        }
        
        /* Responsive Anpassungen */
        @media (max-width: 768px) {
            .ui {
                top: 15px;
                left: 15px;
                gap: 10px;
            }
            
            .game-stats {
                padding: 15px;
            }
            
            .leaderboard {
                top: 15px;
                right: 15px;
                padding: 15px;
                max-width: 200px;
            }
            
            .minimap {
                bottom: 15px;
                right: 15px;
                width: 150px;
                height: 110px;
            }
            
            .controls-hint {
                bottom: 160px;
                left: 15px;
                font-size: 12px;
            }
            
            .touch-controls, .touch-boost {
                display: block;
            }
        }
    </style>
</head>
<body>
    <div class="loader-container" id="loader">
        <div class="loader"></div>
        <div class="loader-text" id="loaderText">Lade Astora...</div>
        <div class="progress-bar">
            <div class="progress" id="loaderProgress"></div>
        </div>
        <div class="branding">
            <h2>Astora</h2>
            <p>Schlange der Ewigkeit</p>
        </div>
    </div>
    
    <div class="language-selector">
        <button class="language-btn active" data-lang="de">DE</button>
        <button class="language-btn" data-lang="en">EN</button>
    </div>
    
    <div class="game-title">ASTORA<span>Schlange der Ewigkeit</span></div>
    <div class="boost-overlay" id="boostOverlay"></div>
    <div class="custom-cursor" id="customCursor"></div>
    
    <canvas id="gameCanvas"></canvas>
    
    <div class="ui">
        <div class="game-stats">
            <div class="stat-item">
                <span class="stat-label" data-i18n="length">L√§nge:</span>
                <span class="stat-value" id="score">10</span>
            </div>
            <div class="stat-item">
                <span class="stat-label" data-i18n="speed">Geschwindigkeit:</span>
                <span class="stat-value" id="speed-display">2.0</span>
            </div>
            <div class="stat-item">
                <span class="stat-label" data-i18n="food">Futter:</span>
                <span class="stat-value" id="food-counter">0/75</span>
            </div>
            <div class="stat-item">
                <span class="stat-label" data-i18n="points">Punkte:</span>
                <span class="stat-value" id="points">0</span>
            </div>
            <div class="stat-item">
                <span class="stat-label" data-i18n="level">Level:</span>
                <span class="stat-value" id="level">1</span>
            </div>
            <div class="stat-item">
                <span class="stat-label" data-i18n="xp">XP:</span>
                <span class="stat-value" id="xp">0%</span>
            </div>
        </div>
        <button id="boostBtn" data-i18n="boost">üöÄ BOOST (F4)</button>
    </div>

    <div class="level-indicator">
        <div data-i18n="level">Level <span id="current-level">1</span></div>
        <div class="xp-bar">
            <div class="xp-progress" id="xp-progress"></div>
        </div>
    </div>

    <div class="leaderboard">
        <h3>üèÜ <span data-i18n="leaderboard">Bestenliste</span></h3>
        <div id="leaderboardList"></div>
    </div>

    <canvas class="minimap" id="minimap"></canvas>

    <div class="ability-container">
        <div class="ability-btn" id="blastAbility" title="Energieblast (F1)">
            üí•
            <div class="cooldown-overlay"></div>
        </div>
        <div class="ability-btn" id="shieldAbility" title="Schild (F2)">
            üõ°Ô∏è
            <div class="cooldown-overlay"></div>
        </div>
        <div class="ability-btn" id="healAbility" title="Heilung (F3)">
            ‚ù§Ô∏è
            <div class="cooldown-overlay"></div>
        </div>
    </div>
    
    <div class="controls-hint">
        <span data-i18n="shortcuts">Tastenk√ºrzel:</span> 
        <span class="key-hint">F1</span> <span data-i18n="blast">Energieblast</span>, 
        <span class="key-hint">F2</span> <span data-i18n="shield">Schild</span>, 
        <span class="key-hint">F3</span> <span data-i18n="heal">Heilung</span>,
        <span class="key-hint">F4</span> <span data-i18n="boost">Boost</span>
    </div>
    
    <div class="audio-controls">
        <button class="audio-btn" id="musicToggle">üéµ</button>
        <button class="audio-btn" id="soundToggle">üîä</button>
    </div>

    <div id="gameOver" class="game-over">
        <h2>‚öîÔ∏è <span data-i18n="gameOver">Game Over!</span> ‚öîÔ∏è</h2>
        <div class="final-stats">
            <div class="final-stat">
                <strong data-i18n="finalLength">Finale L√§nge</strong>
                <div id="finalScore">0</div>
            </div>
            <div class="final-stat">
                <strong data-i18n="maxSpeed">Max Speed</strong>
                <div id="maxSpeed">0</div>
            </div>
            <div class="final-stat">
                <strong data-i18n="points">Punkte</strong>
                <div id="finalPoints">0</div>
            </div>
            <div class="final-stat">
                <strong data-i18n="time">Zeit</strong>
                <div id="gameTime">0s</div>
            </div>
            <div class="final-stat">
                <strong data-i18n="level">Level</strong>
                <div id="finalLevel">1</div>
            </div>
            <div class="final-stat">
                <strong data-i18n="enemiesDefeated">Gegner besiegt</strong>
                <div id="enemiesDefeated">0</div>
            </div>
        </div>
        <button class="restart-btn" id="restartButton" data-i18n="restart">üîÑ Neu starten</button>
    </div>
    
    <div class="achievement-container" id="achievementContainer"></div>
    
    <!-- Touch-Steuerung f√ºr Mobilger√§te -->
    <div class="touch-controls" id="touchControls">
        <div class="joystick">
            <div class="joystick-handle" id="joystickHandle"></div>
        </div>
    </div>
    
    <div class="touch-boost" id="touchBoost">
        üöÄ
    </div>

    <!-- Audio Elemente -->
    <audio id="backgroundMusic" loop>
        <source src="https://cdn.pixabay.com/download/audio/2023/11/05/audio_9e1e3d6e1c.mp3?filename=epic-cinematic-trailer-11120.mp3" type="audio/mpeg">
    </audio>
    <audio id="eatSound" src="https://cdn.pixabay.com/download/audio/2021/08/04/audio_52b5f1a0c3.mp3?filename=power-up-6768.mp3"></audio>
    <audio id="boostSound" src="https://cdn.pixabay.com/download/audio/2021/08/04/audio_6c9f0a3d9d.mp3?filename=rocket-whoosh-6982.mp3"></audio>
    <audio id="levelUpSound" src="https://cdn.pixabay.com/download/audio/2022/03/19/audio_6b6f4c8e4d.mp3?filename=achievement-bell-600.mp3"></audio>
    <audio id="gameOverSound" src="https://cdn.pixabay.com/download/audio/2022/03/19/audio_0a5b4f9a8a.mp3?filename=negative_beeps-6008.mp3"></audio>
    <audio id="powerUpSound" src="https://cdn.pixabay.com/download/audio/2022/03/19/audio_4c5a1c9a4a.mp3?filename=magic-spell-676.mp3"></audio>
    <audio id="abilitySound" src="https://cdn.pixabay.com/download/audio/2021/08/04/audio_3c9c6f4e4c.mp3?filename=magic-spell-676.mp3"></audio>

    <script>
        // ==== INTERNATIONALISIERUNG ====
        const translations = {
            de: {
                length: "L√§nge:",
                speed: "Geschwindigkeit:",
                food: "Futter:",
                points: "Punkte:",
                level: "Level:",
                xp: "XP:",
                boost: "üöÄ BOOST (F4)",
                leaderboard: "Bestenliste",
                shortcuts: "Tastenk√ºrzel:",
                blast: "Energieblast",
                shield: "Schild",
                heal: "Heilung",
                gameOver: "Game Over!",
                finalLength: "Finale L√§nge",
                maxSpeed: "Max Speed",
                time: "Zeit",
                enemiesDefeated: "Gegner besiegt",
                restart: "üîÑ Neu starten",
                loading: "Lade Astora..."
            },
            en: {
                length: "Length:",
                speed: "Speed:",
                food: "Food:",
                points: "Points:",
                level: "Level:",
                xp: "XP:",
                boost: "üöÄ BOOST (F4)",
                leaderboard: "Leaderboard",
                shortcuts: "Shortcuts:",
                blast: "Energy Blast",
                shield: "Shield",
                heal: "Heal",
                gameOver: "Game Over!",
                finalLength: "Final Length",
                maxSpeed: "Max Speed",
                time: "Time",
                enemiesDefeated: "Enemies Defeated",
                restart: "üîÑ Restart",
                loading: "Loading Astora..."
            }
        };

        let currentLanguage = 'de';
        
        function setLanguage(lang) {
            currentLanguage = lang;
            document.querySelectorAll('[data-i18n]').forEach(el => {
                const key = el.getAttribute('data-i18n');
                if (translations[lang][key]) {
                    if (el.tagName === 'INPUT' || el.tagName === 'TEXTAREA') {
                        el.value = translations[lang][key];
                    } else {
                        el.textContent = translations[lang][key];
                    }
                }
            });
            
            // Aktiviere den entsprechenden Sprachbutton
            document.querySelectorAll('.language-btn').forEach(btn => {
                if (btn.dataset.lang === lang) {
                    btn.classList.add('active');
                } else {
                    btn.classList.remove('active');
                }
            });
        }
        
        // Event-Listener f√ºr Sprachbuttons
        document.querySelectorAll('.language-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                setLanguage(btn.dataset.lang);
            });
        });
        
        // ==== AUDIO SYSTEM ====
        const backgroundMusic = document.getElementById('backgroundMusic');
        const eatSound = document.getElementById('eatSound');
        const boostSound = document.getElementById('boostSound');
        const levelUpSound = document.getElementById('levelUpSound');
        const gameOverSound = document.getElementById('gameOverSound');
        const powerUpSound = document.getElementById('powerUpSound');
        const abilitySound = document.getElementById('abilitySound');
        
        let soundEnabled = true;
        let musicEnabled = true;
        
        // Sound-Einstellungen laden
        if (localStorage.getItem('soundEnabled') !== null) {
            soundEnabled = localStorage.getItem('soundEnabled') === 'true';
        }
        
        if (localStorage.getItem('musicEnabled') !== null) {
            musicEnabled = localStorage.getItem('musicEnabled') === 'true';
        }
        
        function playSound(sound, volume = 0.7) {
            if (!soundEnabled) return;
            
            try {
                sound.volume = volume;
                sound.currentTime = 0;
                sound.play().catch(e => console.log("Sound play failed:", e));
            } catch (e) {
                console.error("Sound error:", e);
            }
        }
        
        function toggleMusic() {
            musicEnabled = !musicEnabled;
            localStorage.setItem('musicEnabled', musicEnabled);
            
            if (musicEnabled) {
                backgroundMusic.play().catch(e => console.log("Music play failed:", e));
                document.getElementById('musicToggle').textContent = 'üéµ';
            } else {
                backgroundMusic.pause();
                document.getElementById('musicToggle').textContent = 'üîá';
            }
        }
        
        function toggleSound() {
            soundEnabled = !soundEnabled;
            localStorage.setItem('soundEnabled', soundEnabled);
            document.getElementById('soundToggle').textContent = soundEnabled ? 'üîä' : 'üîá';
        }
        
        // ==== ACHIEVEMENT SYSTEM ====
        const achievements = {
            firstFood: {
                id: "firstFood",
                title: { de: "Erstes Futter", en: "First Food" },
                description: { de: "Erstes Futter gesammelt!", en: "Collected first food!" },
                icon: "üçé",
                achieved: false
            },
            level5: {
                id: "level5",
                title: { de: "Erfahrungsmeister", en: "Level Master" },
                description: { de: "Level 5 erreicht!", en: "Reached level 5!" },
                icon: "‚≠ê",
                achieved: false
            },
            points1000: {
                id: "points1000",
                title: { de: "Punktesammler", en: "Point Collector" },
                description: { de: "1.000 Punkte erreicht!", en: "Reached 1,000 points!" },
                icon: "üèÜ",
                achieved: false
            },
            enemySlayer: {
                id: "enemySlayer",
                title: { de: "Gegnerbesieger", en: "Enemy Slayer" },
                description: { de: "10 Gegner besiegt!", en: "Defeated 10 enemies!" },
                icon: "‚öîÔ∏è",
                achieved: false
            }
        };
        
        function unlockAchievement(achievementId) {
            const achievement = achievements[achievementId];
            if (!achievement || achievement.achieved) return;
            
            achievement.achieved = true;
            
            const achievementElement = document.createElement('div');
            achievementElement.className = 'achievement';
            achievementElement.innerHTML = `
                <div class="achievement-icon">${achievement.icon}</div>
                <div class="achievement-text">
                    <h3>${achievement.title[currentLanguage]}</h3>
                    <p>${achievement.description[currentLanguage]}</p>
                </div>
            `;
            
            document.getElementById('achievementContainer').appendChild(achievementElement);
            
            // Animation anzeigen
            setTimeout(() => {
                achievementElement.classList.add('show');
                
                // Nach 5 Sekunden ausblenden
                setTimeout(() => {
                    achievementElement.classList.remove('show');
                    setTimeout(() => {
                        achievementElement.remove();
                    }, 500);
                }, 5000);
            }, 100);
        }
        
        // ==== LEVEL-UP ANIMATION ====
        function showLevelUpAnimation() {
            const levelUpDiv = document.createElement('div');
            levelUpDiv.className = 'level-up-animation';
            levelUpDiv.textContent = `${translations[currentLanguage].level} ${gameState.level} !`;
            document.body.appendChild(levelUpDiv);
            
            // Nach der Animation entfernen
            setTimeout(() => {
                levelUpDiv.remove();
            }, 2000);
        }
        
        // ==== GAME CODE ====
        const canvas = document.getElementById("gameCanvas");
        const ctx = canvas.getContext("2d");
        const minimap = document.getElementById("minimap");
        const minimapCtx = minimap.getContext("2d");
        const boostOverlay = document.getElementById("boostOverlay");
        const restartButton = document.getElementById("restartButton");
        const loader = document.getElementById("loader");
        const loaderProgress = document.getElementById("loaderProgress");

        // Canvas-Gr√∂√üe anpassen
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resizeCanvas();
        window.addEventListener("resize", resizeCanvas);

        // Erweiterte Spielvariablen
        let gameState = {
            snake: [{ x: canvas.width / 2, y: canvas.height / 2 }],
            direction: { x: 1, y: 0 },
            size: 10,
            baseSpeed: 2.5,
            currentSpeed: 2.5,
            maxSpeed: 2.5,
            food: [],
            powerUps: [],
            particles: [],
            enemies: [],
            obstacles: [],
            boost: false,
            gameRunning: true,
            lastTime: 0,
            startTime: Date.now(),
            points: 0,
            camera: { x: 0, y: 0 },
            world: { width: 3000, height: 2000 },
            level: 1,
            xp: 0,
            xpToNextLevel: 100,
            abilities: {
                blast: { cooldown: 0, maxCooldown: 10000, active: false },
                shield: { cooldown: 0, maxCooldown: 15000, active: false, duration: 5000, endTime: 0 },
                heal: { cooldown: 0, maxCooldown: 20000, active: false }
            },
            enemiesDefeated: 0,
            shieldActive: false,
            shieldEndTime: 0
        };

        const CONFIG = {
            maxFood: 75,
            foodRadius: 8,
            snakeRadius: 10,
            boostMultiplier: 2.8,
            speedIncrease: 0.025,
            maxSpeedLimit: 10,
            boostShrinkRate: 0.05,
            particleCount: 15,
            cameraSmoothing: 0.1,
            enemySpawnRate: 5000,
            enemyHealth: 100,
            enemyDamage: 10,
            enemySize: 8,
            obstacleCount: 20,
            powerUpTypes: ['speed', 'growth', 'invincibility', 'points'],
            powerUpDuration: 10000,
            powerUpSpawnRate: 15000,
            blastRadius: 100,
            blastDamage: 50,
            healAmount: 20,
            boundaryWidth: 15,
            maxParticles: 500 // Begrenzung f√ºr Performance
        };

        // Lokale Bestenliste
        let leaderboard = JSON.parse(localStorage.getItem('astoraLeaderboard') || '[]');

        // Custom Cursor
        const cursor = document.getElementById('customCursor');
        let mousePos = { x: canvas.width / 2, y: canvas.height / 2 };
        
        document.addEventListener('mousemove', (e) => {
            mousePos.x = e.clientX;
            mousePos.y = e.clientY;
            cursor.style.left = e.clientX - 12 + 'px';
            cursor.style.top = e.clientY - 12 + 'px';
        });

        // Erweiterte Boost-Steuerung
        const boostBtn = document.getElementById("boostBtn");
        
        function startBoost() {
            if (gameState.gameRunning && gameState.size > 8) {
                gameState.boost = true;
                boostBtn.classList.add("boosting");
                boostOverlay.classList.add("active");
                createBoostParticles();
                playSound(boostSound);
            }
        }
        
        function stopBoost() {
            gameState.boost = false;
            boostBtn.classList.remove("boosting");
            boostOverlay.classList.remove("active");
        }

        boostBtn.addEventListener("mousedown", startBoost);
        boostBtn.addEventListener("mouseup", stopBoost);
        boostBtn.addEventListener("mouseleave", stopBoost);
        
        window.addEventListener("keydown", (e) => {
            // Boost (F4)
            if (e.code === "F4") {
                e.preventDefault();
                startBoost();
            }
            
            // F√§higkeiten
            if (e.code === "F1") useBlastAbility();
            if (e.code === "F2") useShieldAbility();
            if (e.code === "F3") useHealAbility();
        });
        
        window.addEventListener("keyup", (e) => {
            if (e.code === "F4") {
                stopBoost();
            }
        });

        // Touch-Steuerung f√ºr Mobilger√§te
        const touchBoost = document.getElementById('touchBoost');
        const joystickHandle = document.getElementById('joystickHandle');
        let touchActive = false;
        let joystickPosition = { x: 0, y: 0 };
        const joystickRadius = 40;

        if ('ontouchstart' in window) {
            document.getElementById('touchControls').style.display = 'block';
            touchBoost.style.display = 'flex';
            
            touchBoost.addEventListener('touchstart', (e) => {
                e.preventDefault();
                startBoost();
            });
            
            touchBoost.addEventListener('touchend', (e) => {
                e.preventDefault();
                stopBoost();
            });
            
            const joystick = document.querySelector('.joystick');
            joystick.addEventListener('touchstart', handleTouchStart);
            document.addEventListener('touchmove', handleTouchMove);
            document.addEventListener('touchend', handleTouchEnd);
            
            function handleTouchStart(e) {
                touchActive = true;
                const rect = joystick.getBoundingClientRect();
                joystickPosition = {
                    x: rect.left + rect.width/2,
                    y: rect.top + rect.height/2
                };
            }
            
            function handleTouchMove(e) {
                if (!touchActive) return;
                e.preventDefault();
                
                const touch = e.touches[0];
                const dx = touch.clientX - joystickPosition.x;
                const dy = touch.clientY - joystickPosition.y;
                const dist = Math.hypot(dx, dy);
                const angle = Math.atan2(dy, dx);
                
                const limitedDist = Math.min(dist, joystickRadius);
                const moveX = limitedDist * Math.cos(angle);
                const moveY = limitedDist * Math.sin(angle);
                
                // Joystick-Handle bewegen
                joystickHandle.style.transform = `translate(${moveX}px, ${moveY}px)`;
                
                // Richtung setzen
                if (dist > 10) {
                    gameState.direction = { 
                        x: dx / dist, 
                        y: dy / dist 
                    };
                }
            }
            
            function handleTouchEnd(e) {
                touchActive = false;
                joystickHandle.style.transform = 'translate(-50%, -50%)';
                gameState.direction = { x: 0, y: 0 };
            }
        }

        // Gegner-System
        function spawnEnemy() {
            if (!gameState.gameRunning || Math.random() > 0.7 || gameState.enemies.length > 15) return;
            
            let x, y;
            const margin = 300;
            const head = gameState.snake[0];
            
            // Sicherstellen, dass Gegner nicht in der N√§he des Spielers spawnen
            let validPosition = false;
            let attempts = 0;
            
            while (!validPosition && attempts < 20) {
                if (Math.random() > 0.5) {
                    x = Math.random() > 0.5 ? 
                        gameState.camera.x - margin : 
                        gameState.camera.x + canvas.width + margin;
                    y = gameState.camera.y + Math.random() * canvas.height;
                } else {
                    x = gameState.camera.x + Math.random() * canvas.width;
                    y = Math.random() > 0.5 ? 
                        gameState.camera.y - margin : 
                        gameState.camera.y + canvas.height + margin;
                }
                
                // Begrenzung auf Welt
                x = Math.max(0, Math.min(gameState.world.width, x));
                y = Math.max(0, Math.min(gameState.world.height, y));
                
                // Distanzpr√ºfung
                const distanceToPlayer = Math.hypot(head.x - x, head.y - y);
                if (distanceToPlayer > 500) {
                    validPosition = true;
                }
                
                attempts++;
            }
            
            if (!validPosition) return;
            
            const enemy = {
                x: x,
                y: y,
                segments: [{x: x, y: y}],
                size: CONFIG.enemySize + Math.random() * 5,
                speed: 1.5 + Math.random() * 0.4,
                direction: {x: 0, y: 0},
                health: CONFIG.enemyHealth * (0.8 + Math.random() * 0.4),
                maxHealth: CONFIG.enemyHealth * (0.8 + Math.random() * 0.4),
                lastDirectionChange: 0,
                directionChangeInterval: 1000 + Math.random() * 2000,
                color: `hsl(${Math.random() * 60}, 70%, 40%)`,
                damage: CONFIG.enemyDamage
            };
            
            gameState.enemies.push(enemy);
        }

        function updateEnemies(deltaTime) {
            const head = gameState.snake[0];
            
            gameState.enemies.forEach(enemy => {
                // Richtung aktualisieren
                enemy.lastDirectionChange += deltaTime * 16.67;
                
                if (enemy.lastDirectionChange > enemy.directionChangeInterval) {
                    enemy.lastDirectionChange = 0;
                    
                    // Entscheidung: Spieler verfolgen oder zuf√§llige Richtung
                    if (Math.random() > 0.3) {
                        // Spieler verfolgen
                        const dx = head.x - enemy.segments[0].x;
                        const dy = head.y - enemy.segments[0].y;
                        const dist = Math.hypot(dx, dy);
                        
                        if (dist > 0) {
                            enemy.direction = {
                                x: dx / dist,
                                y: dy / dist
                            };
                        }
                    } else {
                        // Zuf√§llige Richtung
                        const angle = Math.random() * Math.PI * 2;
                        enemy.direction = {
                            x: Math.cos(angle),
                            y: Math.sin(angle)
                        };
                    }
                }
                
                // Bewegung
                const newHead = {
                    x: enemy.segments[0].x + enemy.direction.x * enemy.speed * deltaTime,
                    y: enemy.segments[0].y + enemy.direction.y * enemy.speed * deltaTime
                };
                
                enemy.segments.unshift(newHead);
                
                // L√§nge anpassen
                while (enemy.segments.length > Math.floor(enemy.size)) {
                    enemy.segments.pop();
                }
                
                // Weltgrenzen
                if (newHead.x < 0 || newHead.x > gameState.world.width || 
                    newHead.y < 0 || newHead.y > gameState.world.height) {
                    // Umkehren bei Grenzen
                    enemy.direction.x *= -1;
                    enemy.direction.y *= -1;
                }
                
                // Kollision mit Spieler
                if (!gameState.shieldActive && Math.hypot(
                    newHead.x - head.x, 
                    newHead.y - head.y
                ) < CONFIG.snakeRadius + CONFIG.enemySize) {
                    // Schaden nehmen
                    gameState.size = Math.max(5, gameState.size - (enemy.damage / 10));
                    
                    // Explosionspartikel
                    for (let i = 0; i < 10; i++) {
                        if (gameState.particles.length < CONFIG.maxParticles) {
                            gameState.particles.push({
                                x: (newHead.x + head.x) / 2,
                                y: (newHead.y + head.y) / 2,
                                vx: (Math.random() - 0.5) * 10,
                                vy: (Math.random() - 0.5) * 10,
                                life: 1,
                                decay: 0.05,
                                color: '#ff4757'
                            });
                        }
                    }
                }
            });
        }

        // Hindernisse
        function spawnObstacles() {
            gameState.obstacles = [];
            for (let i = 0; i < CONFIG.obstacleCount; i++) {
                gameState.obstacles.push({
                    x: Math.random() * gameState.world.width,
                    y: Math.random() * gameState.world.height,
                    width: 50 + Math.random() * 100,
                    height: 50 + Math.random() * 100,
                    rotation: Math.random() * Math.PI * 2
                });
            }
        }

        // Power-Ups
        function spawnPowerUp() {
            if (!gameState.gameRunning || Math.random() > 0.5 || gameState.powerUps.length >= 5) return;
            
            const type = CONFIG.powerUpTypes[Math.floor(Math.random() * CONFIG.powerUpTypes.length)];
            const colors = {
                speed: '#d4af37',
                growth: '#2ed573',
                invincibility: '#7b68ee',
                points: '#ffa502'
            };
            
            const powerUp = {
                x: Math.random() * (gameState.world.width - 200) + 100,
                y: Math.random() * (gameState.world.height - 200) + 100,
                type: type,
                color: colors[type],
                radius: 15,
                pulse: Math.random() * Math.PI * 2,
                duration: CONFIG.powerUpDuration
            };
            
            gameState.powerUps.push(powerUp);
        }

        function applyPowerUp(powerUp) {
            switch (powerUp.type) {
                case 'speed':
                    gameState.baseSpeed = Math.min(
                        CONFIG.maxSpeedLimit * 1.5,
                        gameState.baseSpeed * 1.5
                    );
                    setTimeout(() => {
                        gameState.baseSpeed = Math.min(
                            CONFIG.maxSpeedLimit,
                            gameState.baseSpeed / 1.5
                        );
                    }, powerUp.duration);
                    break;
                    
                case 'growth':
                    gameState.size += 15;
                    break;
                    
                case 'invincibility':
                    gameState.shieldActive = true;
                    gameState.shieldEndTime = Date.now() + powerUp.duration;
                    setTimeout(() => {
                        gameState.shieldActive = false;
                    }, powerUp.duration);
                    break;
                    
                case 'points':
                    gameState.points += 500;
                    break;
            }
            
            // Partikel-Effekt
            for (let i = 0; i < 30; i++) {
                if (gameState.particles.length < CONFIG.maxParticles) {
                    gameState.particles.push({
                        x: powerUp.x,
                        y: powerUp.y,
                        vx: (Math.random() - 0.5) * 10,
                        vy: (Math.random() - 0.5) * 10,
                        life: 1,
                        decay: 0.03,
                        color: powerUp.color
                    });
                }
            }
            
            playSound(powerUpSound);
        }

        // F√§higkeiten
        function useBlastAbility() {
            if (gameState.abilities.blast.cooldown > 0 || !gameState.gameRunning) return;
            
            gameState.abilities.blast.active = true;
            gameState.abilities.blast.cooldown = gameState.abilities.blast.maxCooldown;
            
            const blastBtn = document.getElementById('blastAbility');
            const cooldownOverlay = blastBtn.querySelector('.cooldown-overlay');
            cooldownOverlay.style.height = '100%';
            
            // Cooldown-Animation
            const cooldownInterval = setInterval(() => {
                gameState.abilities.blast.cooldown -= 100;
                const percent = 100 - (gameState.abilities.blast.cooldown / gameState.abilities.blast.maxCooldown * 100);
                cooldownOverlay.style.height = `${100 - percent}%`;
                
                if (gameState.abilities.blast.cooldown <= 0) {
                    clearInterval(cooldownInterval);
                }
            }, 100);
            
            // Energieblast-Effekt
            const head = gameState.snake[0];
            const blastParticles = 50;
            
            for (let i = 0; i < blastParticles; i++) {
                if (gameState.particles.length < CONFIG.maxParticles) {
                    const angle = Math.random() * Math.PI * 2;
                    const speed = Math.random() * 15 + 5;
                    
                    gameState.particles.push({
                        x: head.x,
                        y: head.y,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed,
                        life: 1,
                        decay: 0.02,
                        color: '#ff4757'
                    });
                }
            }
            
            // Gegnern Schaden zuf√ºgen
            gameState.enemies.forEach(enemy => {
                const dist = Math.hypot(
                    enemy.segments[0].x - head.x,
                    enemy.segments[0].y - head.y
                );
                
                if (dist < CONFIG.blastRadius) {
                    enemy.health -= CONFIG.blastDamage * (1 - dist / CONFIG.blastRadius);
                    
                    if (enemy.health <= 0) {
                        // Gegner besiegt
                        const index = gameState.enemies.indexOf(enemy);
                        if (index > -1) {
                            gameState.enemies.splice(index, 1);
                            gameState.points += 100;
                            gameState.xp += 20;
                            gameState.enemiesDefeated++;
                            
                            // XP-Check f√ºr Level-Up
                            if (gameState.xp >= gameState.xpToNextLevel) {
                                levelUp();
                            }
                        }
                    }
                }
            });
            
            playSound(abilitySound);
        }

        function useShieldAbility() {
            if (gameState.abilities.shield.cooldown > 0 || !gameState.gameRunning) return;
            
            gameState.abilities.shield.active = true;
            gameState.abilities.shield.cooldown = gameState.abilities.shield.maxCooldown;
            gameState.abilities.shield.endTime = Date.now() + gameState.abilities.shield.duration;
            gameState.shieldActive = true;
            gameState.shieldEndTime = Date.now() + gameState.abilities.shield.duration;
            
            const shieldBtn = document.getElementById('shieldAbility');
            const cooldownOverlay = shieldBtn.querySelector('.cooldown-overlay');
            cooldownOverlay.style.height = '100%';
            
            // Cooldown-Animation
            const cooldownInterval = setInterval(() => {
                gameState.abilities.shield.cooldown -= 100;
                const percent = 100 - (gameState.abilities.shield.cooldown / gameState.abilities.shield.maxCooldown * 100);
                cooldownOverlay.style.height = `${100 - percent}%`;
                
                if (gameState.abilities.shield.cooldown <= 0) {
                    clearInterval(cooldownInterval);
                }
            }, 100);
            
            setTimeout(() => {
                gameState.shieldActive = false;
                gameState.abilities.shield.active = false;
            }, gameState.abilities.shield.duration);
            
            // Schild-Effekt
            const head = gameState.snake[0];
            
            for (let i = 0; i < 30; i++) {
                if (gameState.particles.length < CONFIG.maxParticles) {
                    const angle = Math.random() * Math.PI * 2;
                    const radius = CONFIG.snakeRadius * 2;
                    
                    gameState.particles.push({
                        x: head.x + Math.cos(angle) * radius,
                        y: head.y + Math.sin(angle) * radius,
                        vx: Math.cos(angle + Math.PI/2) * 2,
                        vy: Math.sin(angle + Math.PI/2) * 2,
                        life: 1,
                        decay: 0.01,
                        color: '#7b68ee'
                    });
                }
            }
            
            playSound(abilitySound);
        }

        function useHealAbility() {
            if (gameState.abilities.heal.cooldown > 0 || !gameState.gameRunning) return;
            
            gameState.abilities.heal.active = true;
            gameState.abilities.heal.cooldown = gameState.abilities.heal.maxCooldown;
            
            const healBtn = document.getElementById('healAbility');
            const cooldownOverlay = healBtn.querySelector('.cooldown-overlay');
            cooldownOverlay.style.height = '100%';
            
            // Cooldown-Animation
            const cooldownInterval = setInterval(() => {
                gameState.abilities.heal.cooldown -= 100;
                const percent = 100 - (gameState.abilities.heal.cooldown / gameState.abilities.heal.maxCooldown * 100);
                cooldownOverlay.style.height = `${100 - percent}%`;
                
                if (gameState.abilities.heal.cooldown <= 0) {
                    clearInterval(cooldownInterval);
                }
            }, 100);
            
            // Heilungseffekt
            gameState.size = Math.min(gameState.size + CONFIG.healAmount, 100);
            
            const head = gameState.snake[0];
            
            for (let i = 0; i < 30; i++) {
                if (gameState.particles.length < CONFIG.maxParticles) {
                    gameState.particles.push({
                        x: head.x,
                        y: head.y,
                        vx: (Math.random() - 0.5) * 5,
                        vy: (Math.random() - 0.5) * 5,
                        life: 1,
                        decay: 0.03,
                        color: '#2ed573'
                    });
                }
            }
            
            playSound(abilitySound);
        }

        // Level-System
        function levelUp() {
            gameState.level++;
            gameState.xp -= gameState.xpToNextLevel;
            gameState.xpToNextLevel = Math.floor(gameState.xpToNextLevel * 1.5);
            
            // Verbesserungen beim Level-Up
            gameState.maxSpeedLimit += 0.5;
            gameState.baseSpeed = Math.min(
                gameState.maxSpeedLimit,
                gameState.baseSpeed + 0.3
            );
            
            // UI-Update
            document.getElementById('level').textContent = gameState.level;
            document.getElementById('current-level').textContent = gameState.level;
            
            // Level-Up-Effekt
            const head = gameState.snake[0];
            
            for (let i = 0; i < 100; i++) {
                if (gameState.particles.length < CONFIG.maxParticles) {
                    const angle = Math.random() * Math.PI * 2;
                    const speed = Math.random() * 10 + 5;
                    
                    gameState.particles.push({
                        x: head.x,
                        y: head.y,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed,
                        life: 1,
                        decay: 0.01,
                        color: `hsl(${Math.random() * 360}, 100%, 70%)`
                    });
                }
            }
            
            // Animation anzeigen
            showLevelUpAnimation();
            playSound(levelUpSound);
            
            // Errungenschaft freischalten
            if (gameState.level === 5 && !achievements.level5.achieved) {
                unlockAchievement('level5');
            }
            
            // Level 2+ Schwierigkeitserh√∂hung
            if (gameState.level > 1) {
                CONFIG.enemySpawnRate = Math.max(2000, CONFIG.enemySpawnRate - 500);
                CONFIG.enemyHealth += 20;
                CONFIG.enemyDamage += 2;
            }
        }

        // Partikel-System
        function createBoostParticles() {
            if (!gameState.boost) return;
            
            const head = gameState.snake[0];
            for (let i = 0; i < 3; i++) {
                if (gameState.particles.length < CONFIG.maxParticles) {
                    gameState.particles.push({
                        x: head.x + (Math.random() - 0.5) * 20,
                        y: head.y + (Math.random() - 0.5) * 20,
                        vx: (Math.random() - 0.5) * 4,
                        vy: (Math.random() - 0.5) * 4,
                        life: 1,
                        decay: 0.02,
                        color: `hsl(${15 + Math.random() * 30}, 100%, ${50 + Math.random() * 30}%)`
                    });
                }
            }
        }

        function createFoodParticles(x, y) {
            for (let i = 0; i < CONFIG.particleCount; i++) {
                if (gameState.particles.length < CONFIG.maxParticles) {
                    gameState.particles.push({
                        x: x,
                        y: y,
                        vx: (Math.random() - 0.5) * 8,
                        vy: (Math.random() - 0.5) * 8,
                        life: 1,
                        decay: 0.05,
                        color: `hsl(${Math.random() * 360}, 100%, 70%)`
                    });
                }
            }
        }

        // Erweiterte Futter-Generierung
        function spawnFood() {
            gameState.food = [];
            while (gameState.food.length < CONFIG.maxFood) {
                let attempts = 0;
                let newFood;
                
                do {
                    newFood = {
                        x: Math.random() * gameState.world.width,
                        y: Math.random() * gameState.world.height,
                        hue: Math.random() * 360,
                        pulse: Math.random() * Math.PI * 2,
                        value: 1 + Math.random() * 2
                    };
                    attempts++;
                } while (attempts < 15 && isNearSnake(newFood, 80));
                
                gameState.food.push(newFood);
            }
        }
        
        function spawnSingleFood() {
            let attempts = 0;
            let newFood;
            
            do {
                newFood = {
                    x: Math.random() * gameState.world.width,
                    y: Math.random() * gameState.world.height,
                    hue: Math.random() * 360,
                    pulse: Math.random() * Math.PI * 2,
                    value: 1 + Math.random() * 2
                };
                attempts++;
            } while (attempts < 15 && isNearSnake(newFood, 80));
            
            if (attempts < 15) {
                gameState.food.push(newFood);
            }
        }

        function isNearSnake(pos, minDistance) {
            return gameState.snake.some(segment => 
                Math.hypot(segment.x - pos.x, segment.y - pos.y) < minDistance
            );
        }

        // Kamera-System
        function updateCamera() {
            const head = gameState.snake[0];
            const targetX = head.x - canvas.width / 2;
            const targetY = head.y - canvas.height / 2;
            
            gameState.camera.x += (targetX - gameState.camera.x) * CONFIG.cameraSmoothing;
            gameState.camera.y += (targetY - gameState.camera.y) * CONFIG.cameraSmoothing;
            
            // Kamera-Grenzen
            gameState.camera.x = Math.max(0, Math.min(gameState.world.width - canvas.width, gameState.camera.x));
            gameState.camera.y = Math.max(0, Math.min(gameState.world.height - canvas.height, gameState.camera.y));
        }

        // Zeichne Kartenbegrenzung mit verbessertem Design
        function drawWorldBoundaries() {
            ctx.save();
            ctx.translate(-gameState.camera.x, -gameState.camera.y);
            
            const boundaryWidth = CONFIG.boundaryWidth;
            const boundaryColor = 'rgba(255, 50, 50, 0.5)';
            
            // Linke Grenze
            if (gameState.camera.x < boundaryWidth) {
                ctx.fillStyle = boundaryColor;
                ctx.fillRect(0, 0, boundaryWidth, gameState.world.height);
                
                // Gl√ºheffekt
                ctx.fillStyle = 'rgba(255, 100, 100, 0.8)';
                ctx.fillRect(0, 0, 5, gameState.world.height);
            }
            
            // Rechte Grenze
            if (gameState.camera.x + canvas.width > gameState.world.width - boundaryWidth) {
                ctx.fillStyle = boundaryColor;
                ctx.fillRect(
                    gameState.world.width - boundaryWidth, 
                    0, 
                    boundaryWidth, 
                    gameState.world.height
                );
                
                // Gl√ºheffekt
                ctx.fillStyle = 'rgba(255, 100, 100, 0.8)';
                ctx.fillRect(gameState.world.width - 5, 0, 5, gameState.world.height);
            }
            
            // Obere Grenze
            if (gameState.camera.y < boundaryWidth) {
                ctx.fillStyle = boundaryColor;
                ctx.fillRect(0, 0, gameState.world.width, boundaryWidth);
                
                // Gl√ºheffekt
                ctx.fillStyle = 'rgba(255, 100, 100, 0.8)';
                ctx.fillRect(0, 0, gameState.world.width, 5);
            }
            
            // Untere Grenze
            if (gameState.camera.y + canvas.height > gameState.world.height - boundaryWidth) {
                ctx.fillStyle = boundaryColor;
                ctx.fillRect(
                    0, 
                    gameState.world.height - boundaryWidth, 
                    gameState.world.width, 
                    boundaryWidth
                );
                
                // Gl√ºheffekt
                ctx.fillStyle = 'rgba(255, 100, 100, 0.8)';
                ctx.fillRect(0, gameState.world.height - 5, gameState.world.width, 5);
            }
            
            ctx.restore();
        }

        // Hauptspiel-Update
        function update(currentTime) {
            if (!gameState.gameRunning) return;
            
            const deltaTime = (currentTime - gameState.lastTime) / 16.67;
            gameState.lastTime = currentTime;

            // Richtung zur Maus berechnen
            const head = gameState.snake[0];
            const worldMouseX = mousePos.x + gameState.camera.x;
            const worldMouseY = mousePos.y + gameState.camera.y;
            
            const dx = worldMouseX - head.x;
            const dy = worldMouseY - head.y;
            const distance = Math.hypot(dx, dy);
            
            if (distance > 30) {
                gameState.direction = { 
                    x: dx / distance, 
                    y: dy / distance 
                };
            }

            // Boost-Partikel
            if (gameState.boost && Math.random() < 0.7) {
                createBoostParticles();
            }

            // Geschwindigkeit
            const boostSpeed = gameState.boost ? CONFIG.boostMultiplier : 1;
            gameState.currentSpeed = gameState.baseSpeed * boostSpeed;
            
            // Snake-Bewegung
            const newHead = {
                x: head.x + gameState.direction.x * gameState.currentSpeed * deltaTime,
                y: head.y + gameState.direction.y * gameState.currentSpeed * deltaTime
            };

            gameState.snake.unshift(newHead);

            // Snake-L√§nge bei Boost
            if (gameState.boost && gameState.size > 8) {
                gameState.size -= CONFIG.boostShrinkRate * deltaTime;
                gameState.size = Math.max(8, gameState.size);
            }

            // Snake k√ºrzen
            while (gameState.snake.length > Math.floor(gameState.size)) {
                gameState.snake.pop();
            }

            // Welt-Kollision
            if (newHead.x < 0 || newHead.x > gameState.world.width || 
                newHead.y < 0 || newHead.y > gameState.world.height) {
                gameOver();
                return;
            }

            // Selbstkollision
            if (gameState.size > 25) {
                for (let i = 15; i < gameState.snake.length; i++) {
                    if (Math.hypot(newHead.x - gameState.snake[i].x, 
                                  newHead.y - gameState.snake[i].y) < CONFIG.snakeRadius) {
                        gameOver();
                        return;
                    }
                }
            }

            // Hindernis-Kollision (Kreis-Rechteck-Kollision)
            gameState.obstacles.forEach(obstacle => {
                // Finde den n√§chsten Punkt am Rechteckrand
                const closestX = Math.max(obstacle.x, Math.min(newHead.x, obstacle.x + obstacle.width));
                const closestY = Math.max(obstacle.y, Math.min(newHead.y, obstacle.y + obstacle.height));
                
                const distance = Math.hypot(newHead.x - closestX, newHead.y - closestY);
                
                if (!gameState.shieldActive && distance < CONFIG.snakeRadius) {
                    gameOver();
                    return;
                }
            });

            // Futter-Kollision
            for (let i = gameState.food.length - 1; i >= 0; i--) {
                const food = gameState.food[i];
                const distance = Math.hypot(food.x - newHead.x, food.y - newHead.y);
                
                if (distance < CONFIG.foodRadius + CONFIG.snakeRadius) {
                    gameState.size += food.value;
                    gameState.points += Math.floor(food.value * 10);
                    gameState.xp += Math.floor(food.value * 2);
                    gameState.baseSpeed = Math.min(
                        CONFIG.maxSpeedLimit, 
                        gameState.baseSpeed + CONFIG.speedIncrease
                    );
                    gameState.maxSpeed = Math.max(gameState.maxSpeed, gameState.baseSpeed);
                    
                    createFoodParticles(food.x, food.y);
                    gameState.food.splice(i, 1);
                    
                    // Neues Futter spawnen
                    spawnSingleFood();
                    
                    // Erstes Futter Achievement
                    if (!achievements.firstFood.achieved) {
                        unlockAchievement('firstFood');
                    }
                    
                    // XP-Check f√ºr Level-Up
                    if (gameState.xp >= gameState.xpToNextLevel) {
                        levelUp();
                    }
                    
                    // Punktzahl-Achievement
                    if (gameState.points >= 1000 && !achievements.points1000.achieved) {
                        unlockAchievement('points1000');
                    }
                    
                    playSound(eatSound);
                }
            }

            // Power-Up-Kollision
            for (let i = gameState.powerUps.length - 1; i >= 0; i--) {
                const powerUp = gameState.powerUps[i];
                const distance = Math.hypot(powerUp.x - newHead.x, powerUp.y - newHead.y);
                
                if (distance < powerUp.radius + CONFIG.snakeRadius) {
                    applyPowerUp(powerUp);
                    gameState.powerUps.splice(i, 1);
                }
            }

            // Gegner aktualisieren
            updateEnemies(deltaTime);
            
            // Tote Gegner entfernen
            for (let i = gameState.enemies.length - 1; i >= 0; i--) {
                if (gameState.enemies[i].health <= 0) {
                    const enemy = gameState.enemies[i];
                    
                    // Explosionspartikel
                    for (let j = 0; j < 30; j++) {
                        if (gameState.particles.length < CONFIG.maxParticles) {
                            gameState.particles.push({
                                x: enemy.segments[0].x,
                                y: enemy.segments[0].y,
                                vx: (Math.random() - 0.5) * 10,
                                vy: (Math.random() - 0.5) * 10,
                                life: 1,
                                decay: 0.03,
                                color: enemy.color
                            });
                        }
                    }
                    
                    gameState.enemies.splice(i, 1);
                    gameState.points += 100;
                    gameState.xp += 20;
                    gameState.enemiesDefeated++;
                    
                    // Gegnerbesieger Achievement
                    if (gameState.enemiesDefeated >= 10 && !achievements.enemySlayer.achieved) {
                        unlockAchievement('enemySlayer');
                    }
                    
                    // XP-Check f√ºr Level-Up
                    if (gameState.xp >= gameState.xpToNextLevel) {
                        levelUp();
                    }
                }
            }

            // Partikel-Update
            for (let i = gameState.particles.length - 1; i >= 0; i--) {
                const particle = gameState.particles[i];
                particle.x += particle.vx;
                particle.y += particle.vy;
                particle.life -= particle.decay;
                
                if (particle.life <= 0) {
                    gameState.particles.splice(i, 1);
                }
            }

            // F√§higkeiten-Cooldown
            Object.keys(gameState.abilities).forEach(ability => {
                if (gameState.abilities[ability].cooldown > 0) {
                    gameState.abilities[ability].cooldown -= deltaTime * 16.67;
                }
            });

            // Schild-Dauer
            if (gameState.shieldActive && Date.now() > gameState.shieldEndTime) {
                gameState.shieldActive = false;
            }

            // Zuf√§llige Gegner spawnen
            if (Math.random() < 0.01 * deltaTime) {
                spawnEnemy();
            }

            // Zuf√§llige Power-Ups spawnen
            if (Math.random() < 0.005 * deltaTime && gameState.powerUps.length < 3) {
                spawnPowerUp();
            }

            updateCamera();
            updateUI();
            updateMinimap();
        }

        // Erweiterte Zeichenfunktionen
        function draw() {
            // Hintergrund-Gradient
            const gradient = ctx.createRadialGradient(
                canvas.width / 2, canvas.height / 2, 0,
                canvas.width / 2, canvas.height / 2, Math.max(canvas.width, canvas.height)
            );
            gradient.addColorStop(0, "#0a111a");
            gradient.addColorStop(0.5, "#070d12");
            gradient.addColorStop(1, "#04090c");
            
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Grid-System
            drawGrid();

            // Zeichne Kartenbegrenzungen
            drawWorldBoundaries();

            ctx.save();
            ctx.translate(-gameState.camera.x, -gameState.camera.y);

            // Hindernisse zeichnen
            ctx.fillStyle = 'rgba(90, 70, 40, 0.7)';
            gameState.obstacles.forEach(obstacle => {
                ctx.save();
                ctx.translate(obstacle.x + obstacle.width/2, obstacle.y + obstacle.height/2);
                ctx.rotate(obstacle.rotation);
                ctx.fillRect(-obstacle.width/2, -obstacle.height/2, obstacle.width, obstacle.height);
                ctx.restore();
            });

            // Futter mit verbessertem Design
            gameState.food.forEach((food, index) => {
                food.pulse += 0.1;
                const pulseFactor = 1 + Math.sin(food.pulse) * 0.2;
                const radius = CONFIG.foodRadius * pulseFactor;
                
                const gradient = ctx.createRadialGradient(
                    food.x, food.y, 0,
                    food.x, food.y, radius * 2
                );
                gradient.addColorStop(0, `hsl(${food.hue}, 100%, 70%)`);
                gradient.addColorStop(0.7, `hsl(${food.hue}, 100%, 50%)`);
                gradient.addColorStop(1, `hsl(${food.hue}, 100%, 10%)`);
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(food.x, food.y, radius, 0, Math.PI * 2);
                ctx.fill();
                
                // Gl√ºheffekt
                ctx.shadowColor = `hsl(${food.hue}, 100%, 50%)`;
                ctx.shadowBlur = 15;
                ctx.beginPath();
                ctx.arc(food.x, food.y, radius * 0.6, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
            });

            // Power-Ups zeichnen
            gameState.powerUps.forEach(powerUp => {
                powerUp.pulse += 0.05;
                const pulseSize = 1 + Math.sin(powerUp.pulse) * 0.2;
                
                // Hauptkreis
                ctx.fillStyle = powerUp.color;
                ctx.beginPath();
                ctx.arc(powerUp.x, powerUp.y, powerUp.radius * pulseSize, 0, Math.PI * 2);
                ctx.fill();
                
                // Gl√ºheffekt
                ctx.shadowColor = powerUp.color;
                ctx.shadowBlur = 20;
                ctx.beginPath();
                ctx.arc(powerUp.x, powerUp.y, powerUp.radius * 0.7, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
                
                // Symbol
                ctx.fillStyle = 'white';
                ctx.font = `${powerUp.radius}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                let symbol = '?';
                switch (powerUp.type) {
                    case 'speed': symbol = '‚ö°'; break;
                    case 'growth': symbol = '‚¨ÜÔ∏è'; break;
                    case 'invincibility': symbol = 'üõ°Ô∏è'; break;
                    case 'points': symbol = 'üí∞'; break;
                }
                
                ctx.fillText(symbol, powerUp.x, powerUp.y);
            });

            // Gegner zeichnen
            gameState.enemies.forEach(enemy => {
                // Segmente
                enemy.segments.forEach((segment, index) => {
                    const opacity = Math.max(0.4, 1 - (index / enemy.segments.length) * 0.8);
                    const radius = CONFIG.enemySize * (1 - index * 0.05);
                    
                    ctx.fillStyle = enemy.color;
                    ctx.globalAlpha = opacity;
                    ctx.beginPath();
                    ctx.arc(segment.x, segment.y, radius, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Gesundheitsbalken f√ºr den Kopf
                    if (index === 0) {
                        ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                        ctx.fillRect(
                            segment.x - CONFIG.enemySize,
                            segment.y - CONFIG.enemySize - 10,
                            CONFIG.enemySize * 2,
                            5
                        );
                        
                        ctx.fillStyle = '#ff4757';
                        ctx.fillRect(
                            segment.x - CONFIG.enemySize,
                            segment.y - CONFIG.enemySize - 10,
                            (CONFIG.enemySize * 2) * (enemy.health / enemy.maxHealth),
                            5
                        );
                    }
                });
                
                ctx.globalAlpha = 1;
            });

            // Snake mit Regenbogen-Effekt
            gameState.snake.forEach((segment, index) => {
                const opacity = Math.max(0.4, 1 - (index / gameState.snake.length) * 0.8);
                const radius = CONFIG.snakeRadius * (1 - index * 0.008);
                const hue = (index * 5 + Date.now() * 0.1) % 360;
                
                let color;
                if (gameState.boost) {
                    color = `hsla(${15 + Math.sin(index * 0.1) * 30}, 100%, 60%, ${opacity})`;
                } else {
                    color = `hsla(${120 + hue * 0.3}, 80%, 60%, ${opacity})`;
                }
                
                // Schatten f√ºr Tiefe
                ctx.shadowColor = color;
                ctx.shadowBlur = 10;
                
                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.arc(segment.x, segment.y, Math.max(3, radius), 0, Math.PI * 2);
                ctx.fill();
                
                // Kopf-Highlights
                if (index === 0) {
                    const eyeSize = 3;
                    const eyeOffset = CONFIG.snakeRadius * 0.6;
                    
                    ctx.fillStyle = "white";
                    ctx.beginPath();
                    ctx.arc(segment.x - eyeOffset * gameState.direction.x + eyeOffset * gameState.direction.y, 
                           segment.y - eyeOffset * gameState.direction.y - eyeOffset * gameState.direction.x, 
                           eyeSize, 0, Math.PI * 2);
                    ctx.arc(segment.x - eyeOffset * gameState.direction.x - eyeOffset * gameState.direction.y, 
                           segment.y - eyeOffset * gameState.direction.y + eyeOffset * gameState.direction.x, 
                           eyeSize, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Schild-Effekt
                    if (gameState.shieldActive) {
                        ctx.strokeStyle = '#7b68ee';
                        ctx.lineWidth = 2;
                        ctx.globalAlpha = 0.5;
                        ctx.beginPath();
                        ctx.arc(segment.x, segment.y, CONFIG.snakeRadius * 1.5, 0, Math.PI * 2);
                        ctx.stroke();
                        ctx.globalAlpha = 1;
                    }
                }
                
                ctx.shadowBlur = 0;
            });

            // Partikel rendern
            gameState.particles.forEach(particle => {
                ctx.globalAlpha = particle.life;
                ctx.fillStyle = particle.color;
                ctx.beginPath();
                ctx.arc(particle.x, particle.y, 2 + particle.life * 3, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1;
            });

            ctx.restore();
        }

        function drawGrid() {
            const gridSize = 50;
            const startX = Math.floor(gameState.camera.x / gridSize) * gridSize;
            const startY = Math.floor(gameState.camera.y / gridSize) * gridSize;
            
            ctx.strokeStyle = "rgba(123, 90, 50, 0.1)";
            ctx.lineWidth = 1;
            
            for (let x = startX; x < gameState.camera.x + canvas.width + gridSize; x += gridSize) {
                ctx.beginPath();
                ctx.moveTo(x - gameState.camera.x, 0);
                ctx.lineTo(x - gameState.camera.x, canvas.height);
                ctx.stroke();
            }
            
            for (let y = startY; y < gameState.camera.y + canvas.height + gridSize; y += gridSize) {
                ctx.beginPath();
                ctx.moveTo(0, y - gameState.camera.y);
                ctx.lineTo(canvas.width, y - gameState.camera.y);
                ctx.stroke();
            }
        }

        function updateMinimap() {
            minimapCtx.fillStyle = "rgba(10, 15, 25, 0.8)";
            minimapCtx.fillRect(0, 0, minimap.width, minimap.height);
            
            const scaleX = minimap.width / gameState.world.width;
            const scaleY = minimap.height / gameState.world.height;
            
            // Hindernisse auf Minimap
            minimapCtx.fillStyle = 'rgba(90, 70, 40, 0.5)';
            gameState.obstacles.forEach(obstacle => {
                minimapCtx.fillRect(
                    obstacle.x * scaleX,
                    obstacle.y * scaleY,
                    obstacle.width * scaleX,
                    obstacle.height * scaleY
                );
            });
            
            // Futter auf Minimap
            gameState.food.forEach(food => {
                minimapCtx.fillStyle = `hsl(${food.hue}, 100%, 50%)`;
                minimapCtx.beginPath();
                minimapCtx.arc(
                    food.x * scaleX,
                    food.y * scaleY,
                    2, 0, Math.PI * 2
                );
                minimapCtx.fill();
            });
            
            // Power-Ups auf Minimap
            gameState.powerUps.forEach(powerUp => {
                minimapCtx.fillStyle = powerUp.color;
                minimapCtx.beginPath();
                minimapCtx.arc(
                    powerUp.x * scaleX,
                    powerUp.y * scaleY,
                    3, 0, Math.PI * 2
                );
                minimapCtx.fill();
            });
            
            // Gegner auf Minimap
            gameState.enemies.forEach(enemy => {
                minimapCtx.fillStyle = enemy.color;
                minimapCtx.beginPath();
                minimapCtx.arc(
                    enemy.segments[0].x * scaleX,
                    enemy.segments[0].y * scaleY,
                    2, 0, Math.PI * 2
                );
                minimapCtx.fill();
            });
            
            // Snake auf Minimap
            minimapCtx.fillStyle = "#00ff00";
            minimapCtx.beginPath();
            minimapCtx.arc(
                gameState.snake[0].x * scaleX,
                gameState.snake[0].y * scaleY,
                3, 0, Math.PI * 2
            );
            minimapCtx.fill();
            
            // Kamera-View
            minimapCtx.strokeStyle = "#d4af37";
            minimapCtx.lineWidth = 2;
            minimapCtx.strokeRect(
                gameState.camera.x * scaleX,
                gameState.camera.y * scaleY,
                canvas.width * scaleX,
                canvas.height * scaleY
            );
        }

        function updateUI() {
            document.getElementById("score").textContent = Math.floor(gameState.size);
            document.getElementById("speed-display").textContent = gameState.baseSpeed.toFixed(1);
            document.getElementById("food-counter").textContent = `${gameState.food.length}/${CONFIG.maxFood}`;
            document.getElementById("points").textContent = gameState.points;
            document.getElementById("level").textContent = gameState.level;
            document.getElementById("xp").textContent = `${Math.floor((gameState.xp / gameState.xpToNextLevel) * 100)}%`;
            document.getElementById("xp-progress").style.width = `${(gameState.xp / gameState.xpToNextLevel) * 100}%`;
            document.getElementById("current-level").textContent = gameState.level;
        }

        function updateLeaderboard() {
            const list = document.getElementById("leaderboardList");
            list.innerHTML = "";
            
            leaderboard.slice(0, 5).forEach((entry, index) => {
                const div = document.createElement("div");
                div.className = "score-entry";
                div.innerHTML = `
                    <span>${index + 1}. ${translations[currentLanguage].length} ${entry.size}</span>
                    <span>${entry.points}pts</span>
                `;
                list.appendChild(div);
            });
        }

        function saveScore() {
            const gameTime = Math.floor((Date.now() - gameState.startTime) / 1000);
            const newEntry = {
                size: Math.floor(gameState.size),
                points: gameState.points,
                speed: gameState.maxSpeed,
                time: gameTime,
                level: gameState.level,
                enemiesDefeated: gameState.enemiesDefeated,
                date: new Date().toLocaleDateString()
            };
            
            leaderboard.push(newEntry);
            leaderboard.sort((a, b) => b.points - a.points);
            leaderboard = leaderboard.slice(0, 10);
            
            try {
                localStorage.setItem('astoraLeaderboard', JSON.stringify(leaderboard));
            } catch (e) {
                console.log('Speichern der Bestenliste nicht m√∂glich');
            }
            
            updateLeaderboard();
        }

        function gameOver() {
            gameState.gameRunning = false;
            stopBoost();
            
            const gameTime = Math.floor((Date.now() - gameState.startTime) / 1000);
            
            document.getElementById("finalScore").textContent = Math.floor(gameState.size);
            document.getElementById("maxSpeed").textContent = gameState.maxSpeed.toFixed(1);
            document.getElementById("finalPoints").textContent = gameState.points;
            document.getElementById("gameTime").textContent = `${gameTime}s`;
            document.getElementById("finalLevel").textContent = gameState.level;
            document.getElementById("enemiesDefeated").textContent = gameState.enemiesDefeated;
            
            const gameOverDiv = document.getElementById("gameOver");
            gameOverDiv.style.display = "block";
            setTimeout(() => gameOverDiv.classList.add("show"), 10);
            
            saveScore();
            playSound(gameOverSound);
            
            // Explosion-Effekt
            for (let i = 0; i < 50; i++) {
                if (gameState.particles.length < CONFIG.maxParticles) {
                    const head = gameState.snake[0];
                    gameState.particles.push({
                        x: head.x,
                        y: head.y,
                        vx: (Math.random() - 0.5) * 15,
                        vy: (Math.random() - 0.5) * 15,
                        life: 1,
                        decay: 0.02,
                        color: `hsl(${Math.random() * 360}, 100%, 70%)`
                    });
                }
            }
        }

        function restartGame() {
            // Vollst√§ndiger Reset des Spielzustands
            gameState = {
                snake: [{ 
                    x: gameState.world.width / 2, 
                    y: gameState.world.height / 2 
                }],
                direction: { x: 1, y: 0 },
                size: 10,
                baseSpeed: 2.5,
                currentSpeed: 2.5,
                maxSpeed: 2.5,
                food: [],
                powerUps: [],
                particles: [],
                enemies: [],
                obstacles: [],
                boost: false,
                gameRunning: true,
                lastTime: 0,
                startTime: Date.now(),
                points: 0,
                camera: { x: 0, y: 0 },
                world: { width: 3000, height: 2000 },
                level: 1,
                xp: 0,
                xpToNextLevel: 100,
                abilities: {
                    blast: { cooldown: 0, maxCooldown: 10000, active: false },
                    shield: { cooldown: 0, maxCooldown: 15000, active: false, duration: 5000, endTime: 0 },
                    heal: { cooldown: 0, maxCooldown: 20000, active: false }
                },
                enemiesDefeated: 0,
                shieldActive: false,
                shieldEndTime: 0
            };
            
            // Errungenschaften zur√ºcksetzen
            Object.values(achievements).forEach(a => a.achieved = false);
            
            const gameOverDiv = document.getElementById("gameOver");
            gameOverDiv.classList.remove("show");
            setTimeout(() => gameOverDiv.style.display = "none", 500);
            
            // Spielwelt neu generieren
            spawnFood();
            spawnObstacles();
            updateUI();
        }

        // ==== INITIALISIERUNG ====
        function initGame() {
            // Setze Sprache
            setLanguage(currentLanguage);
            
            // Audio-Steuerung
            document.getElementById('musicToggle').addEventListener('click', toggleMusic);
            document.getElementById('soundToggle').addEventListener('click', toggleSound);
            
            // Musik starten
            if (musicEnabled) {
                backgroundMusic.play().catch(e => console.log("Music play failed:", e));
            } else {
                document.getElementById('musicToggle').textContent = 'üîá';
            }
            
            // Sound-Icon setzen
            document.getElementById('soundToggle').textContent = soundEnabled ? 'üîä' : 'üîá';
            
            // Spielwelt vorbereiten
            spawnFood();
            spawnObstacles();
            updateUI();
            updateLeaderboard();
            
            // Event-Listener f√ºr Neustart-Button
            restartButton.addEventListener('click', restartGame);
            
            // Touch-Steuerung f√ºr Mobile
            let touchStart = null;
            
            canvas.addEventListener('touchstart', (e) => {
                e.preventDefault();
                touchStart = {
                    x: e.touches[0].clientX,
                    y: e.touches[0].clientY
                };
            });
            
            canvas.addEventListener('touchmove', (e) => {
                e.preventDefault();
                if (!touchStart || !gameState.gameRunning) return;
                
                const touch = e.touches[0];
                mousePos.x = touch.clientX;
                mousePos.y = touch.clientY;
            });
            
            canvas.addEventListener('touchend', (e) => {
                e.preventDefault();
                touchStart = null;
            });

            // Doppel-Touch f√ºr Boost
            let lastTouchTime = 0;
            canvas.addEventListener('touchstart', (e) => {
                const currentTime = Date.now();
                if (currentTime - lastTouchTime < 300) {
                    startBoost();
                    setTimeout(stopBoost, 500);
                }
                lastTouchTime = currentTime;
            });

            // F√§higkeiten f√ºr Touch
            document.getElementById('blastAbility').addEventListener('click', useBlastAbility);
            document.getElementById('shieldAbility').addEventListener('click', useShieldAbility);
            document.getElementById('healAbility').addEventListener('click', useHealAbility);
            
            // Ladebildschirm ausblenden
            setTimeout(() => {
                loader.style.opacity = '0';
                loader.style.visibility = 'hidden';
            }, 3000);
        }

        // ==== HAUPTSCHLEIFE ====
        function enhancedGameLoop(currentTime) {
            if (!gameState.food.length || gameState.food.length < CONFIG.maxFood) {
                spawnFood();
            }
            update(currentTime);
            draw();
            requestAnimationFrame(enhancedGameLoop);
        }

        // ==== START DES SPIELS ====
        window.addEventListener('load', () => {
            // Ladeanimation simulieren
            let progress = 0;
            const interval = setInterval(() => {
                progress += Math.random() * 10;
                if (progress >= 100) {
                    progress = 100;
                    clearInterval(interval);
                    setTimeout(() => {
                        loader.style.opacity = '0';
                        loader.style.visibility = 'hidden';
                        initGame();
                        requestAnimationFrame(enhancedGameLoop);
                    }, 500);
                }
                loaderProgress.style.width = `${progress}%`;
            }, 200);
        });
    </script>
</body>
    </html>
