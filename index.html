// pages/_app.js
import { useState, useEffect, createContext } from 'react';
import { initializeApp } from 'firebase/app';
import { 
  getAuth, onAuthStateChanged, signInWithEmailAndPassword,
  createUserWithEmailAndPassword, signOut, sendEmailVerification
} from 'firebase/auth';
import { 
  getFirestore, doc, getDoc, setDoc, collection, 
  addDoc, updateDoc, serverTimestamp, query, where, 
  getDocs, orderBy, limit
} from 'firebase/firestore';
import { 
  getStorage, ref, uploadBytesResumable, getDownloadURL,
  deleteObject
} from 'firebase/storage';
import Head from 'next/head';
import dynamic from 'next/dynamic';
import { v4 as uuidv4 } from 'uuid';
import '../styles/globals.css';

// Firebase Config
const firebaseConfig = {
  apiKey: process.env.NEXT_PUBLIC_FIREBASE_API_KEY,
  authDomain: process.env.NEXT_PUBLIC_FIREBASE_AUTH_DOMAIN,
  projectId: process.env.NEXT_PUBLIC_FIREBASE_PROJECT_ID,
  storageBucket: process.env.NEXT_PUBLIC_FIREBASE_STORAGE_BUCKET,
  messagingSenderId: process.env.NEXT_PUBLIC_FIREBASE_MESSAGING_SENDER_ID,
  appId: process.env.NEXT_PUBLIC_FIREBASE_APP_ID
};

// Initialize Firebase
const app = initializeApp(firebaseConfig);
const auth = getAuth(app);
const db = getFirestore(app);
const storage = getStorage(app);

// Contexts
const AuthContext = createContext();
const VideoContext = createContext();

// Main App Component
function MyApp({ Component, pageProps }) {
  const [user, setUser] = useState(null);
  const [authLoading, setAuthLoading] = useState(true);
  const [videos, setVideos] = useState([]);
  const [loadingVideos, setLoadingVideos] = useState(true);

  // Auth State Listener
  useEffect(() => {
    const unsubscribe = onAuthStateChanged(auth, async (user) => {
      setUser(user);
      setAuthLoading(false);
      if (user) await fetchVideos();
    });
    return unsubscribe;
  }, []);

  // Fetch Videos
  const fetchVideos = async () => {
    setLoadingVideos(true);
    const q = query(
      collection(db, 'videos'),
      where('isPublic', '==', true),
      orderBy('createdAt', 'desc'),
      limit(50)
    );
    const querySnapshot = await getDocs(q);
    const videosData = [];
    
    querySnapshot.forEach((doc) => {
      videosData.push({ id: doc.id, ...doc.data() });
    });
    
    setVideos(videosData);
    setLoadingVideos(false);
  };

  // Auth Methods
  const login = (email, password) => {
    return signInWithEmailAndPassword(auth, email, password);
  };

  const register = async (email, password) => {
    const userCredential = await createUserWithEmailAndPassword(auth, email, password);
    await sendEmailVerification(userCredential.user);
    return userCredential;
  };

  const logout = () => {
    return signOut(auth);
  };

  // Video Methods
  const uploadVideo = async (file, metadata) => {
    if (!user) throw new Error('Not authenticated');
    
    const videoId = uuidv4();
    const storageRef = ref(storage, `videos/${videoId}`);
    const uploadTask = uploadBytesResumable(storageRef, file);

    return new Promise((resolve, reject) => {
      uploadTask.on('state_changed',
        (snapshot) => {
          // Progress handling can be added here
        },
        (error) => reject(error),
        async () => {
          const downloadURL = await getDownloadURL(uploadTask.snapshot.ref);
          
          await addDoc(collection(db, 'videos'), {
            id: videoId,
            title: metadata.title,
            description: metadata.description,
            genre: metadata.genre,
            isPublic: metadata.isPublic,
            uploaderId: user.uid,
            uploaderEmail: user.email,
            url: downloadURL,
            createdAt: serverTimestamp(),
            views: 0,
            likes: 0,
            dislikes: 0,
            status: 'processing'
          });

          resolve(videoId);
        }
      );
    });
  };

  const deleteVideo = async (videoId) => {
    if (!user) throw new Error('Not authenticated');
    
    const videoRef = doc(db, 'videos', videoId);
    const videoSnap = await getDoc(videoRef);
    
    if (!videoSnap.exists() || videoSnap.data().uploaderId !== user.uid) {
      throw new Error('Unauthorized');
    }

    // Delete from storage
    const videoFileRef = ref(storage, `videos/${videoId}`);
    await deleteObject(videoFileRef);

    // Delete from Firestore
    await updateDoc(videoRef, { status: 'deleted' });
  };

  return (
    <AuthContext.Provider value={{
      user,
      authLoading,
      login,
      register,
      logout
    }}>
      <VideoContext.Provider value={{
        videos,
        loadingVideos,
        uploadVideo,
        deleteVideo,
        fetchVideos
      }}>
        <Head>
          <title>GerKino - Modern Streaming Platform</title>
          <meta name="description" content="AI-powered video streaming" />
          <link rel="icon" href="/favicon.ico" />
        </Head>
        <Component {...pageProps} />
      </VideoContext.Provider>
    </AuthContext.Provider>
  );
}

// Custom Hooks
export function useAuth() {
  const context = useContext(AuthContext);
  if (!context) throw new Error('useAuth must be used within AuthProvider');
  return context;
}

export function useVideo() {
  const context = useContext(VideoContext);
  if (!context) throw new Error('useVideo must be used within VideoProvider');
  return context;
}

// Dynamic Components
const ReactPlayer = dynamic(() => import('react-player/lazy'), { 
  ssr: false,
  loading: () => <div className="player-loading">Loading player...</div>
});

// Pages
export function HomePage() {
  const { videos, loadingVideos } = useVideo();
  const { user } = useAuth();

  return (
    <div className="container">
      <header>
        <h1>GerKino</h1>
        {user ? (
          <button onClick={() => logout()}>Logout</button>
        ) : (
          <Link href="/login">Login</Link>
        )}
      </header>

      <main>
        {loadingVideos ? (
          <div className="loading">Loading videos...</div>
        ) : (
          <div className="video-grid">
            {videos.map(video => (
              <Link key={video.id} href={`/watch/${video.id}`}>
                <div className="video-card">
                  <img src={video.thumbnail || '/placeholder.jpg'} alt={video.title} />
                  <h3>{video.title}</h3>
                  <p>{video.views} views • {video.genre}</p>
                </div>
              </Link>
            ))}
          </div>
        )}
        
        {/* Ad Banner */}
        <div className="ad-banner">
          <img src="/ad-sample.jpg" alt="Advertisement" />
        </div>
      </main>
    </div>
  );
}

export function WatchPage() {
  const router = useRouter();
  const { id } = router.query;
  const [video, setVideo] = useState(null);
  const [loading, setLoading] = useState(true);
  const [showAd, setShowAd] = useState(false);
  const [adCountdown, setAdCountdown] = useState(5);
  const { user } = useAuth();

  useEffect(() => {
    if (!id) return;

    const fetchVideo = async () => {
      setLoading(true);
      const docRef = doc(db, 'videos', id);
      const docSnap = await getDoc(docRef);
      
      if (docSnap.exists()) {
        setVideo(docSnap.data());
        
        // Update view count if not the uploader
        if (user?.uid !== docSnap.data().uploaderId) {
          setTimeout(() => {
            updateDoc(docRef, {
              views: docSnap.data().views + 1
            });
          }, 10000);
        }
      }
      setLoading(false);
    };

    fetchVideo();

    // Show ad for 30% of views
    if (Math.random() < 0.3) {
      setShowAd(true);
      const timer = setInterval(() => {
        setAdCountdown(prev => prev > 1 ? prev - 1 : (clearInterval(timer), setShowAd(false), 0);
      }, 1000);
      return () => clearInterval(timer);
    }
  }, [id, user]);

  if (loading) return <div className="loading">Loading video...</div>;
  if (!video) return <div className="error">Video not found</div>;

  return (
    <div className="watch-container">
      {showAd && (
        <div className="ad-overlay">
          <div className="ad-content">
            <h3>Advertisement</h3>
            <p>Video will play in {adCountdown} seconds</p>
            <button onClick={() => setShowAd(false)}>
              Skip Ad ({adCountdown}s)
            </button>
          </div>
        </div>
      )}
      
      <div className="video-wrapper">
        <ReactPlayer
          url={video.url}
          controls
          width="100%"
          height="100%"
          config={{
            file: {
              attributes: {
                controlsList: 'nodownload'
              }
            }
          }}
        />
      </div>
      
      <div className="video-info">
        <h1>{video.title}</h1>
        <div className="meta">
          <span>{video.views} views</span>
          <span>•</span>
          <span>{new Date(video.createdAt?.toDate()).toLocaleDateString()}</span>
          <span>•</span>
          <span className="genre">{video.genre}</span>
        </div>
        <div className="description">
          <p>{video.description}</p>
        </div>
      </div>
    </div>
  );
}

export function UploadPage() {
  const { user } = useAuth();
  const { uploadVideo } = useVideo();
  const [file, setFile] = useState(null);
  const [progress, setProgress] = useState(0);
  const [metadata, setMetadata] = useState({
    title: '',
    description: '',
    genre: 'other',
    isPublic: true
  });
  const fileInputRef = useRef();

  const handleSubmit = async (e) => {
    e.preventDefault();
    if (!file || !user) return;

    try {
      await uploadVideo(file, metadata);
      alert('Video uploaded successfully!');
      setFile(null);
      setMetadata({
        title: '',
        description: '',
        genre: 'other',
        isPublic: true
      });
      fileInputRef.current.value = '';
    } catch (error) {
      console.error('Upload failed:', error);
      alert('Upload failed: ' + error.message);
    }
  };

  if (!user) {
    return (
      <div className="auth-required">
        <p>You need to login to upload videos</p>
        <Link href="/login">Go to Login</Link>
      </div>
    );
  }

  return (
    <div className="upload-container">
      <h2>Upload Video</h2>
      <form onSubmit={handleSubmit}>
        <div className="form-group">
          <label>Video File (max 50GB)</label>
          <input
            type="file"
            ref={fileInputRef}
            onChange={(e) => setFile(e.target.files[0])}
            accept="video/*"
            required
          />
        </div>
        
        <div className="form-group">
          <label>Title</label>
          <input
            type="text"
            name="title"
            value={metadata.title}
            onChange={(e) => setMetadata({...metadata, title: e.target.value})}
            required
          />
        </div>
        
        <div className="form-group">
          <label>Description</label>
          <textarea
            name="description"
            value={metadata.description}
            onChange={(e) => setMetadata({...metadata, description: e.target.value})}
          />
        </div>
        
        <div className="form-group">
          <label>Genre</label>
          <select
            name="genre"
            value={metadata.genre}
            onChange={(e) => setMetadata({...metadata, genre: e.target.value})}
          >
            <option value="action">Action</option>
            <option value="comedy">Comedy</option>
            <option value="drama">Drama</option>
            <option value="documentary">Documentary</option>
            <option value="sci-fi">Sci-Fi</option>
            <option value="horror">Horror</option>
            <option value="romance">Romance</option>
            <option value="animation">Animation</option>
            <option value="thriller">Thriller</option>
            <option value="music">Music</option>
            <option value="sports">Sports</option>
            <option value="other">Other</option>
          </select>
        </div>
        
        <div className="form-group checkbox">
          <input
            type="checkbox"
            name="isPublic"
            id="isPublic"
            checked={metadata.isPublic}
            onChange={(e) => setMetadata({...metadata, isPublic: e.target.checked})}
          />
          <label htmlFor="isPublic">Make this video public</label>
        </div>
        
        {progress > 0 && (
          <div className="progress-bar">
            <div style={{ width: `${progress}%` }}></div>
          </div>
        )}
        
        <button type="submit" disabled={!file || progress > 0}>
          {progress > 0 ? `Uploading... ${Math.round(progress)}%` : 'Upload'}
        </button>
      </form>
    </div>
  );
}

// Styles (included in JS for completeness)
const styles = `
  :root {
    --primary: #ff4757;
    --secondary: #2f3542;
    --light: #f1f2f6;
    --dark: #1e272e;
  }
  
  * {
    box-sizing: border-box;
    margin: 0;
    padding: 0;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
  }
  
  body {
    background-color: var(--light);
    color: var(--dark);
  }
  
  .container {
    max-width: 1200px;
    margin: 0 auto;
    padding: 20px;
  }
  
  header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 20px 0;
    border-bottom: 1px solid #ddd;
  }
  
  .video-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
    gap: 20px;
    margin: 30px 0;
  }
  
  .video-card {
    background: white;
    border-radius: 8px;
    overflow: hidden;
    box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    transition: transform 0.3s;
  }
  
  .video-card:hover {
    transform: translateY(-5px);
  }
  
  .video-card img {
    width: 100%;
    height: 180px;
    object-fit: cover;
  }
  
  .video-card h3 {
    padding: 10px;
    font-size: 16px;
  }
  
  .video-card p {
    padding: 0 10px 10px;
    font-size: 14px;
    color: #666;
  }
  
  .ad-banner {
    margin: 40px 0;
    padding: 20px;
    background: #f8f9fa;
    border: 1px solid #ddd;
    text-align: center;
  }
  
  .ad-banner img {
    max-width: 100%;
    height: auto;
  }
  
  .watch-container {
    max-width: 1000px;
    margin: 0 auto;
    padding: 20px;
  }
  
  .video-wrapper {
    position: relative;
    padding-top: 56.25%; /* 16:9 Aspect Ratio */
    margin-bottom: 20px;
  }
  
  .video-wrapper > div {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
  }
  
  .video-info h1 {
    font-size: 24px;
    margin-bottom: 10px;
  }
  
  .meta {
    display: flex;
    gap: 10px;
    color: #666;
    margin-bottom: 15px;
  }
  
  .genre {
    text-transform: capitalize;
  }
  
  .description {
    line-height: 1.6;
  }
  
  .ad-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0,0,0,0.9);
    z-index: 1000;
    display: flex;
    justify-content: center;
    align-items: center;
  }
  
  .ad-content {
    background: white;
    padding: 30px;
    border-radius: 8px;
    text-align: center;
    max-width: 500px;
  }
  
  .ad-content button {
    background: var(--primary);
    color: white;
    border: none;
    padding: 10px 20px;
    margin-top: 15px;
    border-radius: 4px;
    cursor: pointer;
  }
  
  .upload-container {
    max-width: 600px;
    margin: 0 auto;
    padding: 20px;
    background: white;
    border-radius: 8px;
    box-shadow: 0 2px 10px rgba(0,0,0,0.1);
  }
  
  .form-group {
    margin-bottom: 15px;
  }
  
  .form-group label {
    display: block;
    margin-bottom: 5px;
    font-weight: 600;
  }
  
  .form-group input[type="text"],
  .form-group input[type="file"],
  .form-group select,
  .form-group textarea {
    width: 100%;
    padding: 10px;
    border: 1px solid #ddd;
    border-radius: 4px;
  }
  
  .form-group textarea {
    min-height: 100px;
  }
  
  .checkbox {
    display: flex;
    align-items: center;
  }
  
  .checkbox input {
    margin-right: 10px;
  }
  
  .progress-bar {
    width: 100%;
    height: 10px;
    background: #f1f2f6;
    border-radius: 5px;
    margin: 15px 0;
    overflow: hidden;
  }
  
  .progress-bar div {
    height: 100%;
    background: var(--primary);
    transition: width 0.3s;
  }
  
  button {
    background: var(--primary);
    color: white;
    border: none;
    padding: 12px 20px;
    border-radius: 4px;
    cursor: pointer;
    font-weight: 600;
    transition: background 0.3s;
  }
  
  button:hover {
    background: #ff6b81;
  }
  
  button:disabled {
    background: #ccc;
    cursor: not-allowed;
  }
  
  .loading, .error {
    text-align: center;
    padding: 50px;
    font-size: 18px;
  }
  
  .auth-required {
    text-align: center;
    padding: 50px;
  }
  
  .auth-required a {
    color: var(--primary);
    text-decoration: none;
    font-weight: 600;
  }
  
  @media (max-width: 768px) {
    .video-grid {
      grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
    }
  }
`;

// Inject styles
if (typeof document !== 'undefined') {
  const styleElement = document.createElement('style');
  styleElement.innerHTML = styles;
  document.head.appendChild(styleElement);
}

export default MyApp;
